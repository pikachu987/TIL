## angularJS 기초

*01_hello.html*

ng-init 는 템플릿이 렌더링되기 전에 모델을 초기화해주는 역활을 한다. {{test}}는 모델의 특정 값을 렌더링하는 표현식이다.

* 사용자 정의한 HTML 태그와 속성으로 정적인 HTML문서에 동적인 특성을 추가한다.
* 이중 괄호 표현식({{expression}}) 은 모델의 값을 표현하는 구분자 역활을 한다.

AngularJS 에서는 프레임워크가 알아볼 수 있는 특별한 HTML 태그와 속성을 모두 디렉티브(directive)라 부른다.


### 양방향 데이터 바인딩

*02_binding.html*

ng-model을 추가해주면 된다.
~~~~
<body ng-app ng-init="name = 'World'">
  hello to : <input ng-model="name" />
  <h1>Hello, {{name}}!</h1>
</body>
~~~~

input 에서 글을 치면 h1태그에서도 바로 글이 추가된다.

대부분의 기존 템플릿 시스템은 모델(변수)과 템플릿을 합쳐 마크업을 만들어내는 한 단계의 렌더링과정을 거친다. 따라서 모델이 변경되면 템플릿을 다시 평가해야 하지만 AngularJS는 사용자가 뷰를 변경하는 즉시 변경 사항이 모델에 반영되고, 모델 변경사항도 템플릿에 즉시 반영된다.

### AngularJS의 MVC 패턴

대부분의 웹 어플리케이션은 잘 알려진 모델-뷰-컨트롤러 패턴을 기반으로 한다. 하지만 MVC는 아키텍쳐용 상위 레벨 패턴이므로 세부적이지 않다는 문제가 있다. 마틴 파울러는 GUI 아키텍처에 관한 글에서 이문제를 요약했다.

"모델 뷰 컨트롤러를 하나의 예로만 생각하자. 종종 패턴이라고 생각하는데 너무 다른 개념이 있어서 패턴이라고 보는 게 전혀 유용하지 않다고 본다. 사람들은 MVC를 각자의 생각대로 이해하고는 모두 MVC라고 설명하고 있다. 이런 상황이 혼란스럽지 않다고 생각된다면 옮겨 말하기 현상으로 인해 사람마다 내용이 조금식 다르게 구현되는 MVC의 안 좋은 면을 경험하게 될 것이다."

이렇게 다양한 MVC 패턴에 대해 AngularJS팀은 매우 실용적인 방식을 선택했다. MVW(모델-뷰-아무거나) 패턴을 기초로 삼았다.


#### ng-controller

*03_mvc.html*

div태그에 ng-controller을 추가했다. 그리고 script으로 $scope라는 변수를 받았다.

##### 스코프
AngularJS 에서 $scope 객체는 뷰(템플릿)에게 도메인 모델을 제공한다. 즉, 스코프 인스턴스에 프로퍼티를 할당하면 템플릿이 렌더링할 수 있는 새로운 값을 지정할 수 있다.
스코프에는 데이터뿐만 아니라 주어진 뷰에 대한 특정 동작도 추가할 수 있다. 동작을 추가하려면 템플릿에 적용할 UI용 로직을 함수로 선언해 스코프 인스턴스에 추가하면 된다.
예를 들어 name변수에 대한 getter함수가 필요하다면
~~~~
var HelloCtrl = function($scope){
	$scope.getName = function(){
		return $scope.name;
	};
}
<h1> Hello, {{getName()}}! </h1>
~~~~
이런식으로 하면 된다.

$scope객체를 사용하면 특정 도메인 모델과 동작을 특정 뷰 레이어에 한정시킬 수 있다. AngularJS 스코프는 개념적으로 볼 때 MVVM 패턴의 뷰 모델과 유사하다.

##### 컨트롤러

컨트롤러의 가장 중요한 역활은 스코프 객체를 초기화는 것이다. 실제로 초기화 로직은 다음과 같은 역활을 담당한다.

* 초기 모델 값 지정
* $scope에 UI 동작(함수) 추가

컨트롤러는 일반적인 자바스크립트 함수다. 즉, 프레임워크틔 특정 클래스를 상속받거나 AngularJS API를 호출하지 않아도 제 기능을 충분히 발휘한다.

> 초기 모델 값을 지정하는 부분에 있어서는 컨트롤러가 ng-init 디렉티브와 동일한 동작을 한다. 그래서 컨트롤러를 사용하면 초기화 로직을 HTML 템플릿에 넣지 않고 자바스크립트로만 작성할 수 있다.

##### 모델

AngularJS의 모델은 평범한 자바스크립트 객체다. 프레임워크의 특정 클래스를 상속받거나 특정 모델 객체를 포함하지 않아도 된다.
기존의 순수한 자바스크립트 클래스나 객체를 모델로 바로 사용할 수 있으며, 추가할 수 있는 프로퍼티도 기본 타입뿐만 아니라 모든 객체나 배열도 가능하다.
AngularJS에 모델을 제공하려면 $scope의 프로퍼티로 단순히 추가하기만 하면 된다.
> AngularJS는 모델 객체가 프레임워크에 의존적이지 않게 만들기 떄문에 침투적(intrusive)이지 않다.



#### 스코프 심화

각 $scope는 Scope 클래스의 인스턴스다. Scope 클래스는 스코프의 생명주기를 관리하는 메소드, 이벤트를 전달하는 메소드, 템플릿을 렌더링하는 과정을 지원하는 메소드를 갖고있다.

$scope인자는 ng-controller 디렉티브가 Scope.$new() 메소드를 호출해서 새로운 스코프를 생성한 것이다. AngularJS에는 $rootScope라는 모든 스코프의 부모스코프가 있으며,  $rootScope인스턴스는 애플리케이션이 초기화될 때 만들어진다.

ng-controller 디렉티브는 스코프를 생성하는 디렉티브 중 하나다. AngularJS는 DOM트리에서 스코프를 생성하는 디렉티브를 만날 때마다 Scope 클래스의 인스턴스를 새로 생성하며, 이렇게 생성된 스코프는 부모 스코프를 가리키는 $parent 프로퍼티를 갖고있다. DOM 트리에는 스코프를 생성하는 디렉티브가 많을 수 있으며, 이 경우 많은 스코프가 생성될 것이다.

> 스코프의 부모-자식 관계는 루트가 $rootScope 인스턴스인 트리 구조다. DOM 트리에 의해 스코프가 생성되므로 스코프의 트리 구조가 DOM 구조와 비슷한 것은 당연하다.

*04_repeat.html*

여기서 ng-repeat 디렉티브는 컬렉션을 순회하면서 컬렉션의 한 요소당 DOM 요소를 하나씩 생성한다. 하지만 여기에는 각 country 마다 새로운 변수를 $scope에 추가하므로 이전에 추가된 값을 오버라이드하기 쉽지 않다는 문제가 있다. AngularJS는 이 문제를 컬렉션의 한 요소마다 새로운 스코프를 생성하는 방법으로 해결했다. 그리고 새로 생성된 스코프는 DOM 트리 구조와 같은 구조이기 때문에 크롬 확장 기능인 Batarang을 사용해 구조를 눈으로 확인할 수 있다.
